// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package adaptors

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addProjectOwner = `-- name: AddProjectOwner :exec
INSERT INTO user_project_access (
    user_id,
    project_id,
    role
) VALUES (
    $1,
    $2,
    'owner'
)
ON CONFLICT (user_id, project_id)
DO UPDATE SET
    role = 'owner',
    updated_at = now()
`

type AddProjectOwnerParams struct {
	UserID    []byte
	ProjectID pgtype.UUID
}

func (q *Queries) AddProjectOwner(ctx context.Context, arg AddProjectOwnerParams) error {
	_, err := q.db.Exec(ctx, addProjectOwner, arg.UserID, arg.ProjectID)
	return err
}

const addViewerToProject = `-- name: AddViewerToProject :exec
INSERT INTO user_project_access (
    user_id,
    project_id,
    role
) VALUES (
    $1,
    $2,
    'viewer'
)
ON CONFLICT (user_id, project_id) DO NOTHING
`

type AddViewerToProjectParams struct {
	UserID    []byte
	ProjectID pgtype.UUID
}

func (q *Queries) AddViewerToProject(ctx context.Context, arg AddViewerToProjectParams) error {
	_, err := q.db.Exec(ctx, addViewerToProject, arg.UserID, arg.ProjectID)
	return err
}

const createProjectInvite = `-- name: CreateProjectInvite :one
INSERT INTO project_invites (
    project_id,
    invite_code,
    created_by,
    expires_at
)
VALUES (
    $1,
    $2,
    $3,
    $4
)
RETURNING invite_code, expires_at
`

type CreateProjectInviteParams struct {
	ProjectID  pgtype.UUID
	InviteCode string
	CreatedBy  []byte
	ExpiresAt  pgtype.Timestamptz
}

type CreateProjectInviteRow struct {
	InviteCode string
	ExpiresAt  pgtype.Timestamptz
}

func (q *Queries) CreateProjectInvite(ctx context.Context, arg CreateProjectInviteParams) (CreateProjectInviteRow, error) {
	row := q.db.QueryRow(ctx, createProjectInvite,
		arg.ProjectID,
		arg.InviteCode,
		arg.CreatedBy,
		arg.ExpiresAt,
	)
	var i CreateProjectInviteRow
	err := row.Scan(&i.InviteCode, &i.ExpiresAt)
	return i, err
}

const getUserProjectRole = `-- name: GetUserProjectRole :one
SELECT role::text
FROM user_project_access
WHERE user_id = $1
  AND project_id = $2
`

type GetUserProjectRoleParams struct {
	UserID    []byte
	ProjectID pgtype.UUID
}

func (q *Queries) GetUserProjectRole(ctx context.Context, arg GetUserProjectRoleParams) (string, error) {
	row := q.db.QueryRow(ctx, getUserProjectRole, arg.UserID, arg.ProjectID)
	var role string
	err := row.Scan(&role)
	return role, err
}

const getValidInviteByCode = `-- name: GetValidInviteByCode :one
SELECT
    id,
    project_id,
    created_by
FROM project_invites
WHERE invite_code = $1
  AND used_at IS NULL
  AND expires_at > now()
FOR UPDATE
`

type GetValidInviteByCodeRow struct {
	ID        pgtype.UUID
	ProjectID pgtype.UUID
	CreatedBy []byte
}

func (q *Queries) GetValidInviteByCode(ctx context.Context, inviteCode string) (GetValidInviteByCodeRow, error) {
	row := q.db.QueryRow(ctx, getValidInviteByCode, inviteCode)
	var i GetValidInviteByCodeRow
	err := row.Scan(&i.ID, &i.ProjectID, &i.CreatedBy)
	return i, err
}

const hasManagerAccess = `-- name: HasManagerAccess :one
SELECT 1
FROM user_project_access
WHERE user_id = $1
  AND project_id = $2
  AND role IN ('manager', 'owner')
`

type HasManagerAccessParams struct {
	UserID    []byte
	ProjectID pgtype.UUID
}

func (q *Queries) HasManagerAccess(ctx context.Context, arg HasManagerAccessParams) (int32, error) {
	row := q.db.QueryRow(ctx, hasManagerAccess, arg.UserID, arg.ProjectID)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const hasOwnerAccess = `-- name: HasOwnerAccess :one
SELECT 1
FROM user_project_access
WHERE user_id = $1
  AND project_id = $2
  AND role = 'owner'
`

type HasOwnerAccessParams struct {
	UserID    []byte
	ProjectID pgtype.UUID
}

func (q *Queries) HasOwnerAccess(ctx context.Context, arg HasOwnerAccessParams) (int32, error) {
	row := q.db.QueryRow(ctx, hasOwnerAccess, arg.UserID, arg.ProjectID)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const listProjectsForUser = `-- name: ListProjectsForUser :many
SELECT
    p.id, p.name, p.description, p.created_by, p.created_at,
    upa.role::text as role
FROM projects p
JOIN user_project_access upa
  ON upa.project_id = p.id
WHERE upa.user_id = $1
ORDER BY p.created_at DESC
`

type ListProjectsForUserRow struct {
	ID          pgtype.UUID
	Name        string
	Description pgtype.Text
	CreatedBy   []byte
	CreatedAt   pgtype.Timestamptz
	Role        string
}

func (q *Queries) ListProjectsForUser(ctx context.Context, userID []byte) ([]ListProjectsForUserRow, error) {
	rows, err := q.db.Query(ctx, listProjectsForUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProjectsForUserRow
	for rows.Next() {
		var i ListProjectsForUserRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersForProject = `-- name: ListUsersForProject :many
SELECT
    u.id        AS user_id,
    u.name      AS user_name,
    upa.role::text AS role
FROM user_project_access upa
JOIN users u
  ON u.id = upa.user_id
WHERE upa.project_id = $1
ORDER BY
    CASE upa.role
        WHEN 'owner' THEN 1
        WHEN 'manager' THEN 2
        WHEN 'viewer' THEN 3
    END,
    u.name
`

type ListUsersForProjectRow struct {
	UserID   []byte
	UserName string
	Role     string
}

func (q *Queries) ListUsersForProject(ctx context.Context, projectID pgtype.UUID) ([]ListUsersForProjectRow, error) {
	rows, err := q.db.Query(ctx, listUsersForProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUsersForProjectRow
	for rows.Next() {
		var i ListUsersForProjectRow
		if err := rows.Scan(&i.UserID, &i.UserName, &i.Role); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markInviteUsed = `-- name: MarkInviteUsed :exec
UPDATE project_invites
SET used_at = now()
WHERE id = $1
`

func (q *Queries) MarkInviteUsed(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, markInviteUsed, id)
	return err
}

const revokeProjectAccess = `-- name: RevokeProjectAccess :exec
DELETE FROM user_project_access
WHERE project_id = $1
  AND user_id = $2
  AND role != 'owner'
`

type RevokeProjectAccessParams struct {
	ProjectID pgtype.UUID
	UserID    []byte
}

func (q *Queries) RevokeProjectAccess(ctx context.Context, arg RevokeProjectAccessParams) error {
	_, err := q.db.Exec(ctx, revokeProjectAccess, arg.ProjectID, arg.UserID)
	return err
}

const updateUserProjectRole = `-- name: UpdateUserProjectRole :exec
UPDATE user_project_access
SET role = $3::text::project_role,
    updated_at = now()
WHERE user_id = $1
  AND project_id = $2
`

type UpdateUserProjectRoleParams struct {
	UserID    []byte
	ProjectID pgtype.UUID
	Column3   string
}

func (q *Queries) UpdateUserProjectRole(ctx context.Context, arg UpdateUserProjectRoleParams) error {
	_, err := q.db.Exec(ctx, updateUserProjectRole, arg.UserID, arg.ProjectID, arg.Column3)
	return err
}
